
import base64
import json
import pytz
from IIC_Models.utils import IIC_Time
from IIC_Models.EDIServer.Member import INS_Member
from Payers.IIC.QNXT_API import QNXT_270_Mixin, QNXT_UM_Mixin
from Payers.IIC.generate_270_xml_request import EDI_270_271_XML, create_segment
from Payers.IIC.Payer_WebAPI import Payer_Call_Mixin
from Payers.IIC.JIVA_Base import JIVA_DB_Plugin, JIVA_WebAPI, JIVA_Provider, JIVA_EB, JIVA_PA 
from IIC_Models.utils import classproperty

   
###############################################################################
class My_JIVA_WebAPI(JIVA_WebAPI):


    class My_EB_API(QNXT_270_Mixin, QNXT_UM_Mixin, JIVA_EB):
        """
        The database plug-in override for this QNXT payer
        """
        https_verify = False
        
        #X_TZ_EnvId = '3'
        
        #eligibility_url = 'https://drsvttapiisrp.chchealth.org'
        #eligibility_url = 'https://72.249.143.134'
        
        #host_url = 'https://drsvttapiisrp.chchealth.org'
        #host_url = 'https://72.249.143.134'
        #production_host_url = 'https://testqweb2.chp.org' #??
        
        #acess_token_url ="https://drsvttapiisrp.chchealth.org/qnxtsts"
        # acess_token_url ="https://72.249.143.134/qnxtsts"    
        #production_acess_token_url = 'https://testqdh.chp.org/qnxtsts' #??
        
        #TODO: change the below values with actual payer's values. 
        # edi_270_sender_id = 'payer_sender_id'
        # edi_270_receiver_id = 'payer_receiver_id'
        # edi_270_gs_sender_id = 'payer_sender_id'
        # edi_270_gs_receiver_id = 'payer_receiver_id'
        #edi_270_sender_id = 'TTAP_User'
        #edi_270_receiver_id = 'TTAP_User'
        #edi_270_gs_sender_id = 'TTAP_User'
        #edi_270_gs_receiver_id = 'TTAP_User'


        #--------------------------------------------------------------------------
        @classmethod
        def get_headers_call_json_for_access_token(cls):
            '''
            oAuth2: get access token
            '''
            #CHC wants Basic token and env id to be passed.
            headers = {
                    "Accept": 'application/json',
                    "Authorization": 'Basic VFRBUF9Vc2VyOnhUSjE0QA==',
                    "X-TZ-Envid": cls.X_TZ_EnvId,
                    "Content-Type": cls.token_call_content_type,
                    }
            call_json = None
            return headers, call_json

        #--------------------------------------------------------------------------
        @classproperty
        def call_headers(cls):
            headers = super().call_headers
            headers["X-TZ-Envid"] = cls.X_TZ_EnvId#'3'
            return headers

        #--------------------------------------------------------------------------
        @classproperty
        def eb_call_token(cls):
            base64_token = base64.b64encode(cls.payer_userID.encode()+b':'+cls.payer_password.encode())
            token = "Basic "+base64_token.decode()
            return token
            
        #--------------------------------------------------------------------------
        @classmethod
        def get_member_enrollment(cls, memid, asOfDate, healthPlanId):
            """
                asOfDate: The format is YYYY-MM-DD
                overwrite to make it work when healthPlanId is not valid.
            """
            URL = '/qnxtapi/Member/enrollments/search'
            params = {
                    "memid":memid,
                    "asOfDate": asOfDate,
                    "segType": 'INT'
            }
                
            response = cls.payer_call(URL, params=params, do_get_check=False)
            resposne_dict = response.json()
            enrollment_list = resposne_dict.get('results',[])
            
            if not enrollment_list:
                raise LookupError(f"Did not found enrollment for member id {memid} for date {asOfDate}")
            
            enrollment_dict = enrollment_list[0]
            for enrolment in enrollment_list:
                if enrolment['primaryStatus'].upper() == 'P':
                    enrollment_dict = enrolment
                    break
                
            return enrollment_dict

        #--------------------------------------------------------------------------
        @classmethod
        def _get_member_by_healthid(cls, full_name, dob, healthid, on_secondary_id=False, as_list=False):
            '''
                CHC uses QNXT 550 and member search uses POST method instead of GET.

                To ensure we get a unique record we need to pass the full_name. The
                format for name is "<lastname>, <firstname> <middle initial>". We can
                pass just the lastname and firstname
                dob: YYYY-MM-DD
                -VS 10/21/2018
            '''
            URL = '/qnxtapi/Member/members/search'
            data = {}
            #TODO: what happens when passing empty data
            if full_name and full_name!= '':
                data["name"] = full_name
            if dob and dob != '':
                data["birthDate"] = dob
            if on_secondary_id:
                data["secondaryId"] = healthid
            else:
                data["healthPlanId"] = healthid

            response = cls.payer_call(URL, data=data, do_get_check=False)
            resposne_dict = json.loads(response.text)
            members_list = resposne_dict.get('results',[])
            
            #return data as a list
            if as_list:
                return members_list

            if not members_list:
                raise LookupError(f"Did not found member for healthplan/secondary id {healthid}.")

            member_dict = members_list[0]

            if on_secondary_id:
                for member in members_list:
                    if member['secondaryId'] == healthid and member['status'].upper() == 'ACTIVE':
                        member_dict = member
                        break

            return member_dict

        #--------------------------------------------------------------------------
        @classmethod
        def is_existing_member(cls, healthplan_id, first_name=None, last_name=None, dob=None):
            '''
            Query INS_Member collection to return the member object.
            '''
            db_member = None
            query = {'mid': healthplan_id}
            if first_name:
                query['fn'] = first_name
            if last_name:
                query['ln'] = last_name
            if dob and isinstance(dob, str):
                dob = IIC_Time.strptime(dob, '%Y-%m-%d')
                utc_date = IIC_Time(dob.year, dob.month, dob.day, tzinfo=pytz.utc)
                query['dob'] = utc_date
            
            member = INS_Member.objects(__raw__= query)
            db_member = member[0] if len(member) == 1 else None

            return db_member

        
        #--------------------------------------------------------------------------
        @classmethod
        def get_EDI_eligibility(cls, edi_isa, on_secondary_id):
            env_ids = cls.Multiple_EnvIds

            #Extract full_name, healthplan_id and dob
            loop_c = edi_isa._p('loop_2000C/loop_2100C')
            #TODO Handle loop_c is None, nm1_seg is None
            nm1_seg = loop_c._p("NM1")
            last_name = nm1_seg._p("n3") or ''
            first_name = nm1_seg._p("n4") or ''
            full_name = '{}, {}'.format(last_name.upper(), first_name.upper())
            healthplan_id = nm1_seg._p("n9")
            
            dmg_seg = loop_c._p("DMG") if loop_c._p("DMG") else None
            dob = dmg_seg._p("n2") if dmg_seg else ''

            if dob and dob.isdigit() and len(dob) == 8:
                dob = dob[:4]+'-'+dob[4:6]+'-'+dob[6:]
            else:
                dob = ''

            db_member = cls.is_existing_member(healthplan_id, first_name, last_name, dob)
            #check if the member exists, call GET member by memid api
            if db_member and db_member.payer_member_data.get('X_TZ_EnvId') and db_member.secondary_account_number: 
                cls.X_TZ_EnvId = db_member.payer_member_data.get('X_TZ_EnvId')
                asOfDate = IIC_Time.now_utc().strftime('%Y-%m-%d')
                #get_member_by_memid api returns member info as dict.
                member_dict = cls.get_member_by_memid(db_member.secondary_account_number, asOfDate)
            else:
                #For new members, perform member search in all QNXT envs.
                for env_id in env_ids:
                    cls.X_TZ_EnvId = env_id
                    members_list = cls._get_member_by_healthid(full_name, dob, healthplan_id, on_secondary_id, as_list=True)
                    
                    if members_list: #break loop if member is found.             
                        break

                #check if the member is not found in all QNXT instances.s
                if not members_list:
                    #TODO: Throw AAA Error
                    raise LookupError(f"Did not found member for healthplan/secondary id {healthplan_id} in all QNXT environments.")

                #check the results of member search api
                member_dict = members_list[0]

                if on_secondary_id:
                    for member in members_list:
                        if member['secondaryId'] == healthplan_id and member['status'].upper() == 'ACTIVE':
                            member_dict = member
                            break

            #call eligibility SOAP, enrollment and add to database. 
            response, isa = cls._get_EDI_eligibility(edi_isa, on_secondary_id, member_info)
            #Attach the member_dict info to isa
            #isa.member_lookup_info = member_dict
            member_info = {}
            member_info["member_dict"] = member_dict
            cls.add_member_info(isa, on_secondary_id, member_info)

            return response, isa

        #--------------------------------------------------------------------------   
        @classmethod
        def _get_EDI_eligibility(cls, edi_isa, on_secondary_id):
            '''
            Part of the code from EDI eligibility call.
            #TODO: Move to QNXT_Base
            '''
            gs = edi_isa.first_GS()
            
            o_isa_s_id = edi_isa.interchange_sender_id_AN_06
            o_isa_r_id = edi_isa.interchange_receiver_id_AN_08
            o_g_s_id = gs.application_senders_code_AN_02
            o_g_r_id = gs.application_receivers_code_AN_03
            
            try:
                edi_isa.interchange_sender_id_AN_06 = cls.edi_270_sender_id
                edi_isa.interchange_receiver_id_AN_08 = cls.edi_270_receiver_id
                gs.application_senders_code_AN_02 = cls.edi_270_gs_sender_id
                gs.application_receivers_code_AN_03 = cls.edi_270_gs_receiver_id
                
                eligibility_request = EDI_270_271_XML(edi_isa)
                
                #print(f'request xml:\n{eligibility_request.xml_270_request}')
                URL = '/qnxt/api/connect/hipaaMember/EligibilityBenefit_270_271'
                headers = cls.call_headers
                headers["Authorization"] = cls.eb_call_token
        
                ProcessLogId, ProcessLogDetailId = cls._get_ProcessLogDetailId()
                data = {
                        "HeaderId": ProcessLogId, #"LOG3000010035",
                        "DetailId": ProcessLogDetailId, #"LOG3000010036",
                        "Xml": eligibility_request.xml_270_request,
                        }
        
                data = json.dumps(data)
            
                response = cls.payer_xml_call(URL, headers=headers, data=data)
                response_dict = json.loads(response.text)
                    
                response_xml = response_dict.get('Data', {}).get("Xml")
                if not response_xml:
                    raise Exception("No Eligibility Response xml")
                
                isa = EDI_270_271_XML.parse_271_xml_response(edi_isa, response_xml)
                #print('response isa:\n', isa.print_edi().replace('~', '~\n'))

            except Exception as e:
                raise e
            
            gs = isa.first_GS()
            
            isa.interchange_sender_id_AN_06 = o_isa_s_id
            isa.interchange_receiver_id_AN_08 = o_isa_r_id
            gs.application_senders_code_AN_02 = o_g_s_id
            gs.application_receivers_code_AN_03 = o_g_r_id

            # QNXT has problem that it always reports AAA 51 in loop B,
            # If we got EB information, remove 2100B AAA, 
            loop_2100B = isa._p('loop_2000B/loop_2100B')
            if loop_2100B.seg_AAA_list:
                if isa._p('loop_2000D'):
                    loop_2110 = isa._p('loop_2000D/loop_2100D/loop_2110D')
                else:
                    loop_2110 = isa._p('loop_2000C/loop_2100C/loop_2110C')

                if loop_2110:
                    loop_2100B.seg_AAA_list = []
            return response, isa
    
    #--------------------------------------------------------------------------
    @classmethod
    def add_member_info(cls, isa, on_secondary_id, member_info=None):
        #TODO: Move to QNXT_Base
        #Check for AAA segment.
        if isa.has_this_seg('AAA'):
            #print('**** AAA 0****')
            #print(isa.print_edi())
            return isa
        
        loop_CD = isa._p('loop_2000D/loop_2100D')
        if not loop_CD:
            loop_CD = isa._p('loop_2000C/loop_2100C')
        
        if not loop_CD:
            return isa
        
        NM1 = loop_CD._p('NM1')
        DMG = loop_CD._p('DMG')
            
        healthid = NM1._p('n9')


        #if member_lookup_info exists, use member_dict instead of the member search api.
        # if hasattr(isa, "member_lookup_info") and isinstance(isa.member_lookup_info, dict):
        #     member_dict = isa.member_lookup_info
        if member_info and isinstance(member_info, dict):
                member_dict = member_info["member_dict"]
        else:
            #if not, call member search api
            lname = NM1._p('n3') or ''
            fname = NM1._p('n4') or ''
            dob = DMG._p('n2') or ''
            
            full_name = '{}, {}'.format(lname.upper(), fname.upper())
            
            # Here we get a list 
            if dob and dob.isdigit() and len(dob) == 8:
                dob = dob[:4]+'-'+dob[4:6]+'-'+dob[6:]
            else:
                dob = ''
                
            member_dict = cls._get_member_by_healthid(full_name, dob, healthid, on_secondary_id)
        if not member_dict:
            #print('**** AAA 1****')		
            return isa
        
        # Since we are passing full_name & dob this should be a unique record - VS 10/21/2018
        # for data in member_list:
        #     mlname = data['name'].split(',')[0]
        #     mfname = data['name'].split(' ')[1]
            
        #     mdob = ''.join(data['birthDate'].split('T')[0].split('-'))
        #     if lname.strip() == mlname.upper().strip()and fname.strip() == mfname.upper().strip() and dob == mdob:
        #         member_dict = data 
        #         break
        
        #--------
        member_id = member_dict["memId"]
        gender = member_dict["sex"]
        if member_id:
            loop_CD.seg_REF_list = [create_segment({'_seg':'REF', 'REF01':'EA', 'REF02': member_id})]
            if not loop_CD.seg_DMG:
                raise Exception("Patinet Demographic info missing in response")
            loop_CD.seg_DMG.gender_code_ID_03 = gender
            
            #When member has more than one health plan. 
            #We have to make sure which plan is correct for the given healthplan id or member id
            #So add the right plan to the eligibility response. 
            #Provider portal can pick right based this plan name provided here.
            
            asOfDate = IIC_Time.now_utc().strftime('%Y-%m-%d')
            enroll_dict = cls.get_member_enrollment(member_id, asOfDate, healthid)
            plan_description = enroll_dict.get('planDescription')
            plan_id = enroll_dict.get('planId')
            loop_CD.seg_REF_list.append(create_segment({'_seg':'REF', 'REF01':'18', 'REF02': plan_id, 'REF03': plan_description[:50]}))

        # TODO: add member mail address using payer_member_data:
        '''
        call a API to get memeber mail information and return it as:
        payer_member_data = {'mail': {'name_title': name_title, # can be empty
                                      'address_line_1': address_line_1,
                                      'address_line_2': address_line_2, # can be empty  
                                      'city': city,
                                      'state': state,
                                      'zip': zip,
                                      'country': country, # can be empty  
                                     }
                            }
        '''
        #Save environment ID
        isa.payer_member_data = {
            'X_TZ_EnvId': cls.X_TZ_EnvId
        }
        #isa.payer_member_data = payer_member_data   
        return isa

   
    EB_API = My_EB_API

    class My_JIVA_PA(JIVA_PA):
        pass
    PA_API = My_JIVA_PA

    class My_JIVA_Provider(JIVA_Provider): 
        pass
    PRD_API = My_JIVA_Provider



###############################################################################
class DB_Plugin(JIVA_DB_Plugin):
    """
    The database plug-in override for this payer
    """
    jiva_api = My_JIVA_WebAPI
    
    #_payer_id = payer_info.id_number_ST
    _business_rules = {
                        'payer_holidays' : ['01/01/2016', '01/18/2016', '02/15/2016', '05/30/2016', '07/04/2016', 
                                            '09/05/2016', '10/10/2016', '11/24/2016', '11/25/2016', '12/26/2016',
                                            '01/02/2017', '01/16/2017', '02/20/2017', '05/29/2017', '07/04/2017', 
                                            '09/04/2017', '10/09/2017', '11/23/2017', '11/24/2017', '12/25/2017'],
                       #'Request_threshhold'    : None,         # minutes
                       'authorization_duration': 90,           # days
                       'Supported extra certification types': ['3', '4'],
                       'global_reject_override': {'action':'A4',
                                                 'reasons':['0W'],
                                                 'message':None,
                                                 'adjudication_memo':None
                                                },
                       'quantity_rule'         :'LIMITED',     #allowed types LIMITED, FIXED, PEND, LIMITED PEND
                       'no guideline override' :{'action':'A4', 
                                                 'reasons':['0M'], 
                                                 'message': 'The requested service is not covered in this pilot'
                                                },
                       'disclaimer'            : 'Payment is based on member eligibility, medical necessity review, '
                                                  'where applicable and QNXT Payer Mutual Insurance Company provider '
                                                  'contractual agreement. Authorization does not guarantee payment.',
                        'no case matched show all cases': True,                         
                       'auto_approve_cancel': True, # Flag to auto approve all cancel requests. 
                       'support_document_workflow':True, # This flag is to enable doc work flow from  Payer
                    }

    #--------------------------------------------------------------------------
    @classmethod
    def member_plan_type(cls, member):
        return None

    #--------------------------------------------------------------------------
    @classmethod
    def service_specific_restrictions(cls):
        start_date_now = IIC_Time.now()
        delta = 3
        payer_holidays = cls.get_business_rules().get('payer_holidays', [])
        start_date = str(IIC_Time.get_next_business_day(start_date_now, delta, payer_holidays).date())
        psr = {
            "AR":{
                "service_type_restrictions": {
                    "default": {
                        "servicing_providers": ["0", "1"] # 0 must be a facility, 1 must be a provider
                    }
                },

                "qualifier": {
                    "default": {
                        "quantity_qualifier": "DY",
                        "unit": None,
                        "time_period_qualifier": None,
                    }
                },
               "event_dates": {
                   "start_date_min": str(IIC_Time.get_next_business_day(start_date_now, 3, payer_holidays).date()),
                   "end_date_delta"  : 4,
                }
            },
            "HS":{
                "service_type_restrictions": {
                    "default": {
                        "servicing_providers": ["0", "1"] # 0 can be a facility or a physician
                    },
                    "62": {
                       "servicing_providers": ["1"], # 1 Servicing Provider, can be
                    },
                    "18": {
                       "servicing_providers": ["1"], # 1 Servicing Provider, can be
                    }
                },
               "qualifier": {
                    "default": {
                        "quantity_qualifier": "VS",
                        "unit": None,
                        "time_period_qualifier": None,
                    },
                    "88": {
                        "quantity_qualifier": "FL",
                        "time_period_qualifier": "27",
                    }
                },
               "event_dates": {
                   "start_date_min": str(IIC_Time.get_next_business_day(start_date_now, -1, payer_holidays).date()),
                   "end_date_delta"  : 0,
                }
            }
        }

        
        return psr

    #--------------------------------------------------------------------------
    def is_member_coverage_active(self):
        '''
        Check if the current member health plan active
        '''
        if self._use_qnxt_calls:
            # let QNXT to check coverage_active 
            return super().is_member_coverage_active()
        
        return self.iic_member_identifier.health_plan_coverage_status in ['1', '2', '3', '4', '5']

    #--------------------------------------------------------------------------
    @classmethod
    def is_member_eligible_on_date(cls, member, date291):
        '''
        check if the catched eligibility_and_benefits is good for date291
        '''
        if member and date291 is not None:
            date291 = IIC_Time.trunc_to_date_utc(date291)
            start_date = member.start_date or IIC_Time.time_earliest
            end_date = member.end_date or IIC_Time.time_latest
            if end_date >= date291 >= start_date:
                #For default we are using group as product offering.
                # It is better to override this at payer level DB Plugin
                payer_plan_info = member.group_id.id
                return True, start_date, end_date, payer_plan_info

        return False, None, None, None

    
